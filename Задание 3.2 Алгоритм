Подробное текстовое описание алгоритма:

Шаг 1: Получение и парсинг запроса

Сервер получает POST запрос на /api/users/register
Проверяется Content-Type: должен быть application/json
Парсится JSON тело запроса
Если JSON некорректен → возвращается 400 Bad Request
Шаг 2: Проверка обязательных полей

Проверяется наличие всех обязательных полей: firstName, lastName, userName, password, captchaToken
Если какое-то поле отсутствует → возвращается 400 с указанием недостающего поля
Шаг 3: Валидация формата полей

firstName: проверка длины (1-50 символов), удаление лишних пробелов
lastName: проверка длины (1-50 символов), удаление лишних пробелов
userName:

длина 3-30 символов
только латинские буквы, цифры и подчеркивание
регистронезависимая проверка (приводим к нижнему регистру)
password: комплексная проверка по требованиям:

Минимум 8 символов
Хотя бы одна цифра (0-9)
Хотя бы одна заглавная буква (A-Z)
Хотя бы одна строчная буква (a-z)
Хотя бы один специальный символ (!@#$%^&* и т.д.)
Если пароль не соответствует требованиям → возвращается 422 с детальным описанием ошибки
Шаг 4: Верификация reCAPTCHA

Из запроса извлекается captchaToken
Отправляется POST запрос к Google reCAPTCHA API (https://www.google.com/recaptcha/api/siteverify) с секретным ключом
Полученный ответ проверяется: success должен быть true
Если капча не пройдена → возвращается 400 с сообщением о необходимости пройти капчу
Шаг 5: Проверка уникальности пользователя

В базе данных выполняется поиск пользователя с таким же userName (регистронезависимо)
Если пользователь найден → возвращается 409 Conflict с сообщением "User exists!"
Шаг 6: Хеширование пароля

Пароль хешируется с помощью безопасного алгоритма (например, bcrypt с солью)
Оригинальный пароль нигде не сохраняется
Шаг 7: Создание записи в базе данных

Генерируется уникальный userId
В таблицу users добавляется запись со следующими полями:

user_id (уникальный идентификатор)
first_name
last_name
user_name (в нижнем регистре для регистронезависимости)
password_hash
created_at (текущая дата и время)
is_active (устанавливается в true)
Шаг 8: Генерация токена (опционально)

Может быть сгенерирован JWT токен для автоматической авторизации после регистрации
Токен возвращается в ответе или сохраняется в HTTP-only cookie
Шаг 9: Подготовка успешного ответа

Формируется JSON ответ с данными пользователя
Исключаются конфиденциальные данные (хеш пароля)
Добавляется сообщение об успешной регистрации
Шаг 10: Отправка ответа

Возвращается HTTP статус 201 Created
В теле ответа отправляются данные зарегистрированного пользователя
Дополнительные проверки (защита от атак):

Rate limiting: Ограничение количества запросов на регистрацию с одного IP
SQL injection protection: Использование параметризованных запросов
XSS protection: Санитизация всех строковых полей
Логирование: Запись всех попыток регистрации (успешных и неуспешных)
